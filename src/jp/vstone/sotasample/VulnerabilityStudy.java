package jp.vstone.sotasample;

import java.awt.Color;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Scanner;

import jp.vstone.RobotLib.*;
import jp.vstone.camera.CRoboCamera;
import jp.vstone.camera.FaceDetectResult;

/**
 * Embodied Vulnerability Study: Does Sota's vulnerable body language 
 * increase user emotional disclosure?
 * 
 * 3 Conditions:
 * A) Confident Sota (upright, fast, bright)
 * B) Uncertain Sota (questioning pose, slow, dim)
 * C) Distressed Sota (head back, jerky, flickering)
 * 
 * Measures: User voice features + behavioral observation + trust questionnaire
 * 
 * @author Research Team
 */
public class VulnerabilityStudy {

    static final String TAG = "VulnerabilityStudy";
    
    // Research parameters
    enum RobotCondition {
        CONFIDENT,
        UNCERTAIN,
        DISTRESSED
    }
    
    private CRobotMem mem;
    private CSotaMotion motion;
    private CRoboCamera cam;
    private String participantID;
    private RobotCondition condition;
    private FileWriter logFile;
    private long experimentStartTime;

    public VulnerabilityStudy(String participantID, RobotCondition condition) {
        this.participantID = participantID;
        this.condition = condition;
        this.mem = new CRobotMem();
        this.motion = new CSotaMotion(mem);
    }

    /**
     * Initialize robot connection and logging
     */
    public boolean initialize() {
        CRobotUtil.Log(TAG, "Initializing for Participant: " + participantID 
            + " Condition: " + condition);

        if (!mem.Connect()) {
            CRobotUtil.Log(TAG, "ERROR: Failed to connect to robot");
            return false;
        }

        if (!motion.InitRobot_Sota()) {
            CRobotUtil.Log(TAG, "ERROR: Failed to initialize Sota");
            mem.Disconnect();
            return false;
        }

        // Create log file
        try {
            String timestamp = new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date());
            String filename = "logs/participant_" + participantID + "_" + 
                            condition.toString() + "_" + timestamp + ".txt";
            new File("logs").mkdirs();
            logFile = new FileWriter(filename, true);
            log("=== Vulnerability Study - Participant " + participantID + " ===");
            log("Condition: " + condition);
            log("Start time: " + new Date());
            log("Robot Firmware Rev: " + mem.FirmwareRev.get());
            
        } catch (IOException e) {
            e.printStackTrace();
        }

        motion.ServoOn();
        experimentStartTime = System.currentTimeMillis();
        CRobotUtil.Log(TAG, "Initialization complete");
        return true;
    }

    /**
     * Set robot to specified condition and maintain it
     * 
     * CONDITION A (CONFIDENT):
     *   - Head upright (pitch +100)
     *   - Shoulders back (pitch -300)
     *   - Bright green LEDs, full mouth brightness
     *   - Fast servo movements (500ms)
     * 
     * CONDITION B (UNCERTAIN):
     *   - Head tilted down (pitch -300, yaw +50)
     *   - Shoulders relaxed
     *   - Dim yellow LEDs
     *   - Slow servo movements (1500ms) - uncertainty effect
     * 
     * CONDITION C (DISTRESSED):
     *   - Head back/confused (pitch -500, yaw -100)
     *   - Body tensed (body yaw +150)
     *   - Limbs raised (elbow +300)
     *   - Red flickering LEDs
     *   - Jerky movements (800ms)
     */
    public void activateCondition() {
        CRobotPose pose = new CRobotPose();

        switch (condition) {
            case CONFIDENT:
                log("[CONDITION] Activating CONFIDENT Sota");
                // Servo layout: 1=HEAD_Y, 2=HEAD_P, 3=HEAD_R, 4=BODY_Y, 
                //              5=L_SHOULDER, 6=R_SHOULDER, 7=L_ELBOW, 8=R_ELBOW
                pose.SetPose(
                    new Byte[]{1, 2, 3, 4, 5, 6, 7, 8},
                    new Short[]{0, 100, 0, 0, -300, -300, -200, -200}  // Upright, shoulders back
                );
                pose.setLED_Sota(Color.GREEN, Color.GREEN, 255, Color.WHITE);
                motion.play(pose, 500);  // Fast, confident transition
                CRobotUtil.wait(500);
                break;

            case UNCERTAIN:
                log("[CONDITION] Activating UNCERTAIN Sota");
                pose.SetPose(
                    new Byte[]{1, 2, 3, 4, 5, 6, 7, 8},
                    new Short[]{50, -300, -100, 0, -100, -100, 0, 0}  // Head down, questioning
                );
                pose.setLED_Sota(Color.YELLOW, Color.YELLOW, 128, Color.ORANGE);
                motion.play(pose, 1500);  // Slow, hesitant
                CRobotUtil.wait(1500);
                break;

            case DISTRESSED:
                log("[CONDITION] Activating DISTRESSED Sota");
                pose.SetPose(
                    new Byte[]{1, 2, 3, 4, 5, 6, 7, 8},
                    new Short[]{-100, -500, 200, 150, 100, 100, 300, 300}  // Head back, limbs raised
                );
                pose.setLED_Sota(Color.RED, Color.RED, 100, Color.RED);
                motion.play(pose, 800);
                CRobotUtil.wait(800);
                
                // Add flickering effect for distressed
                log("[CONDITION] Adding LED flicker effect");
                for (int i = 0; i < 3; i++) {
                    pose.setLED_Sota(Color.RED, Color.RED, 255, Color.RED);
                    motion.play(pose, 150);
                    CRobotUtil.wait(150);
                    pose.setLED_Sota(Color.RED, Color.RED, 50, Color.RED);
                    motion.play(pose, 150);
                    CRobotUtil.wait(150);
                }
                break;
        }
    }

    /**
     * Record user voice during dialogue
     * @param durationSeconds How long to record (in seconds)
     * @param prompt The question prompt being asked
     */
    public boolean recordUserVoice(int durationSeconds, String prompt) {
        try {
            String timestamp = new SimpleDateFormat("HHmmss").format(new Date());
            String filename = "voice/" + participantID + "_" + condition.toString() 
                            + "_" + timestamp + ".wav";
            new File("voice").mkdirs();

            log("[VOICE] Recording user response to: " + prompt);
            log("[VOICE] Duration: " + durationSeconds + "s File: " + filename);

            CRecordMic mic = new CRecordMic();
            mic.startRecording(filename, durationSeconds);
            mic.waitend();

            log("[VOICE] Recording complete: " + filename);
            return true;

        } catch (Exception e) {
            CRobotUtil.Log(TAG, "Error recording voice: " + e.getMessage());
            log("[VOICE] ERROR: " + e.getMessage());
            return false;
        }
    }

    /**
     * Run dialogue sequence - asking 5 personal questions
     * These are designed to elicit emotional disclosure
     */
    public void runDialogueSequence() {
        log("\n[DIALOGUE] Starting dialogue sequence");

        String[] questions = {
            "What is your name?",
            "What makes you feel happy?",
            "How do you handle stressful situations?",
            "What is a personal challenge you face?",
            "If you could change one thing about yourself, what would it be?"
        };

        for (int i = 0; i < questions.length; i++) {
            log("\n[Q" + (i + 1) + "] " + questions[i]);

            // Play attention beep
            try {
                CPlayWave.PlayWave_wait("./sound/beep.wav");
            } catch (Exception e) {
                log("[AUDIO] Warning: beep.wav not found, continuing");
            }

            // Record user's response (20 seconds max)
            recordUserVoice(20, questions[i]);

            // Log current robot state
            logCurrentRobotState();

            // Pause between questions
            CRobotUtil.wait(2000);
        }

        log("\n[DIALOGUE] Dialogue sequence complete");
    }

    /**
     * Log current robot servo positions and LED state
     */
    public void logCurrentRobotState() {
        try {
            CRobotPose currentPose = motion.getReadPose();
            long elapsed = System.currentTimeMillis() - experimentStartTime;
            
            String state = String.format("[STATE] T=%dms | Servos active | Condition=%s",
                elapsed, condition.toString());
            log(state);
        } catch (Exception e) {
            log("[STATE] Error reading pose: " + e.getMessage());
        }
    }

    /**
     * Maintain the robot condition for extended duration
     * Periodically reinforces the condition with small movements
     * while asking follow-up questions
     */
    public void runConditionMaintenance() {
        log("\n[MAINTENANCE] Starting condition maintenance (5 min)");
        
        long maintenanceEndTime = System.currentTimeMillis() + (5 * 60 * 1000);
        int questionIndex = 0;
        
        String[] prompts = {
            "How are you feeling right now?",
            "What do you think of our conversation?",
            "Is there anything else you'd like to share?"
        };
        
        while (System.currentTimeMillis() < maintenanceEndTime) {
            // Every 90 seconds, reinforce the condition
            activateCondition();
            
            // Ask follow-up questions
            String currentPrompt = prompts[questionIndex % prompts.length];
            recordUserVoice(15, currentPrompt);
            logCurrentRobotState();
            
            questionIndex++;
            CRobotUtil.wait(30000);  // 30 seconds between reinforcements
        }
        
        log("[MAINTENANCE] Condition maintenance complete");
    }

    /**
     * Run the complete experiment protocol for one participant
     */
    public void runFullExperiment() {
        try {
            // Initialization delay to let participant adjust
            log("\n[EXPERIMENT] Experiment starting in 3 seconds...");
            CRobotUtil.wait(3000);
            
            // Activate condition
            activateCondition();
            CRobotUtil.wait(2000);  // Let user observe robot state
            
            // Run dialogue
            runDialogueSequence();
            
            // Maintain condition during extended interaction
            runConditionMaintenance();
            
            // Return to neutral pose
            log("\n[NEUTRAL] Returning robot to neutral pose");
            CRobotPose neutral = new CRobotPose();
            neutral.SetPose(
                new Byte[]{1, 2, 3, 4, 5, 6, 7, 8},
                new Short[]{0, 0, 0, 0, 0, 0, 0, 0}
            );
            neutral.setLED_Sota(Color.WHITE, Color.WHITE, 200, Color.WHITE);
            motion.play(neutral, 1000);
            CRobotUtil.wait(1000);
            
        } catch (Exception e) {
            CRobotUtil.Log(TAG, "Error during experiment: " + e.getMessage());
            log("[ERROR] " + e.getMessage());
            e.printStackTrace();
        }
    }

    /**
     * Cleanup and close experiment
     */
    public void shutdown() {
        try {
            log("\n[SHUTDOWN] Experiment ended at: " + new Date());
            long duration = System.currentTimeMillis() - experimentStartTime;
            log("[SHUTDOWN] Total duration: " + (duration / 1000) + " seconds");
            
            motion.ServoOff();
            mem.Disconnect();
            
            if (logFile != null) {
                logFile.close();
            }
            
            CRobotUtil.Log(TAG, "Experiment complete - logs saved");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * Utility: Write to log file with timestamp (elapsed time)
     */
    private void log(String message) {
        try {
            long elapsed = System.currentTimeMillis() - experimentStartTime;
            String timestamped = String.format("[%05d ms] %s", elapsed, message);
            System.out.println(timestamped);
            if (logFile != null) {
                logFile.write(timestamped + "\n");
                logFile.flush();
            }
        } catch (IOException e) {
            System.err.println("Logging error: " + e.getMessage());
        }
    }

    /**
     * Main entry point
     * 
     * Usage:
     *   java VulnerabilityStudy <participant_id> <condition>
     * 
     * Example:
     *   java VulnerabilityStudy P001 CONFIDENT
     *   java VulnerabilityStudy P002 UNCERTAIN
     *   java VulnerabilityStudy P003 DISTRESSED
     */
    public static void main(String[] args) {
        if (args.length < 2) {
            System.out.println("=== Embodied Vulnerability Study ===");
            System.out.println("Usage: java VulnerabilityStudy <participant_id> <condition>");
            System.out.println("  Conditions: CONFIDENT, UNCERTAIN, DISTRESSED");
            System.out.println("\nExample:");
            System.out.println("  java VulnerabilityStudy P001 CONFIDENT");
            System.out.println("  java VulnerabilityStudy P002 UNCERTAIN");
            System.out.println("  java VulnerabilityStudy P003 DISTRESSED");
            return;
        }

        String participantID = args[0];
        RobotCondition condition;
        
        try {
            condition = RobotCondition.valueOf(args[1].toUpperCase());
        } catch (IllegalArgumentException e) {
            System.err.println("Invalid condition: " + args[1]);
            System.err.println("Must be one of: CONFIDENT, UNCERTAIN, DISTRESSED");
            return;
        }

        VulnerabilityStudy study = new VulnerabilityStudy(participantID, condition);

        if (!study.initialize()) {
            System.err.println("Failed to initialize study");
            return;
        }

        try {
            study.runFullExperiment();
        } finally {
            study.shutdown();
        }
    }
}
